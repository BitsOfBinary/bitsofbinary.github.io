---
layout: post
title: "100 Days of YARA - Day 85"
date: 2023-03-26 00:00:00 -0000
categories: yara
---

# AcidBox - SSP DLL PE Meta Features - Part 4
The AcidBox loaders have four exported functions:
- `InitPhysicalInterfaceA`
- `InitSecurityInterfaceA`
- `SpLsaModeInitialize`
- `UpdateSecurityContext`

While the middle two exports appear to be named after standard Windows API functions (e.g. [InitSecurityInterfaceA](https://learn.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-initsecurityinterfacea) and [SpLsaModeInitialize](https://learn.microsoft.com/en-us/windows/win32/api/ntsecpkg/nc-ntsecpkg-splsamodeinitializefn)), the first and last exports appear to be unique. So we can look for DLLs that export those in our rules:
```
import "pe"

rule AcidBox_SSP_DLL_Loader_Unique_Exports {
    meta:
        description = "Detects AcidBox SSP DLL loaders, based on having unique exported functions"
        author = "BitsOfBinary"
        reference = "https://unit42.paloaltonetworks.com/acidbox-rare-malware/"
        hash = "003669761229d3e1db0f5a5b333ef62b3dffcc8e27c821ce9018362e0a2df7e9"
        
    condition:
        pe.exports("InitPhysicalInterfaceA") or
        pe.exports("UpdateSecurityContext")
}
```

While we can use the PE module for this purpose, it also makes sense to search for the strings too, in case they are embedded in another file, being called elsewhere, etc.
```
rule AcidBox_SSP_DLL_Loader_Unique_Exports_Strings {
    meta:
        description = "Detects the strings of unique exported functions of AcidBox SSP DLL loaders"
        author = "BitsOfBinary"
        reference = "https://unit42.paloaltonetworks.com/acidbox-rare-malware/"
        hash = "003669761229d3e1db0f5a5b333ef62b3dffcc8e27c821ce9018362e0a2df7e9"
        
    strings:
        $ = "InitPhysicalInterfaceA"
        $ = "UpdateSecurityContext"
        
    condition:
        any of them
}
```