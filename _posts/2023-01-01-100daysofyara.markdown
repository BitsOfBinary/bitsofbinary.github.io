---
layout: post
title: "100 Days of YARA - 2023"
redirect_from:
  - /yara/2023/01/01/100daysofyara-day-1.html
  - /yara/2023/01/02/100daysofyara-day-2.html
  - /yara/2023/01/03/100daysofyara-day-3.html
  - /yara/2023/01/04/100daysofyara-day-4.html
  - /yara/2023/01/05/100daysofyara-day-5.html
  - /yara/2023/01/06/100daysofyara-day-6.html
  - /yara/2023/01/07/100daysofyara-day-7.html
  - /yara/2023/01/08/100daysofyara-day-8.html
  - /yara/2023/01/09/100daysofyara-day-9.html
  - /yara/2023/01/10/100daysofyara-day-10.html
date: 2023-01-01 00:00:00 -0000
categories: yara
---

## Note
This is a consolidated post of all 100 days of posts from 2023.

# Day 1 - 100 Days of YARA
I'm a big fan of [YARA](https://github.com/VirusTotal/yara). It's a tool that makes it possible for anyone interested to write static signatures, whether to classify specific strains of malware, perform broader threat hunting, or even parsing files.

In 2022, [Greg Lesnewich](https://twitter.com/greglesnewich) started #100DaysofYARA; an initiative, similar to #100DaysOfCode, to engage with YARA for the first 100 days of the year. This can either be writing YARA rules, contributing to the source code, creating tools to help automate YARA, or generally learning more about the tool/helping teach others.

Last year, I didn't contribute to the full 100 days, but was inspired by the event to create a module in YARA to parse LNK files: [https://github.com/VirusTotal/yara/pull/1732](https://github.com/VirusTotal/yara/pull/1732)

This year, I'd like to highlight this module and what it's capable of, as well as trying to contribute on as many of the days that I can!

![I love YARA memes](/assets/2023-01-01-always-has-been.jpg)

To start with, I'd always recommend starting by looking through the YARA documentation to see how to write rules. This is a document I spend a lot of time in: [https://yara.readthedocs.io/en/stable/writingrules.html](https://yara.readthedocs.io/en/stable/writingrules.html)

I'd also recommend checking out [Florian Roth's guide for YARA performance](https://github.com/Neo23x0/YARA-Performance-Guidelines), which can give some good insight into why rules like the following are not great:
```
import "math"

rule CPU_Eater {
    meta:
        description = "Please don't actually use this rule, it's realllllly bad"
        
    condition:
        for all j in (0 .. filesize) : (
            for all i in (0 .. j) : (
                math.entropy(i, j) > 0
            )
        )
}
```

And with that terrible rule out of the way, we can start moving on to more useful content from today onwards!

# Day 2 - YARA Modules
YARA is primarily designed to be used for efficient string matching (which it does very well). But one of its most powerful features (in my opinion) is the ability to create and use [modules](https://yara.readthedocs.io/en/stable/modules.html). These can be used for file parsing (such as [PE](https://yara.readthedocs.io/en/stable/modules/pe.html), [ELF](https://yara.readthedocs.io/en/stable/modules/elf.html) or [.NET](https://yara.readthedocs.io/en/stable/modules/dotnet.html) binaries), utility functions to aid in writing rules (such as [hashing algorithms](https://yara.readthedocs.io/en/stable/modules/hash.html), or [maths functions](https://yara.readthedocs.io/en/stable/modules/math.html)), to help debug your rules (e.g. via the [console module](https://yara.readthedocs.io/en/stable/modules/console.html)), or anything you can think of that can be written in C using YARA's API!

![Available YARA modules](/assets/2023-01-02_default_yara_modules.png "Available YARA modules")

Personally, I find myself using the PE module the most, which also happens to be the most built out default YARA module. I highly recommend reading through its documentation to see what it can do, and if there's something missing then raise an issue on GitHub! There are many active contributors to YARA who will be willing to try and implement it.

I'll give some example rules using the PE module over the next couple of days to give some inspiration for how they can be used!

# Day 3 - YARA Module Example 1 - Imphash and Rich Header Hash
A simple, yet effective way of using the PE module to cluster samples is via hash values of specific components of the PE: namely, the [import hash](https://www.mandiant.com/resources/blog/tracking-malware-import-hashing) (or imphash) and the [rich header hash](https://www.giac.org/paper/grem/6321/leveraging-pe-rich-header-static-alware-etection-linking/169729).

Both of these hash values can prove to be quite unique, and make it possible write YARA based off them. For example, if I take the SHA-256 hash `a37a290863fe29b9812e819e4c5b047c44e7a7d7c40e33da6f5662e1957862ab` from a [report by Mandiant on APT42](https://mandiant.com/resources/blog/apt42-charms-cons-compromises), we can write the following the rule which can be used to cluster further samples:
```
import "pe"
import "hash"

rule APT42_CHAIRSMACK_PE_Metadata {
    meta:
        description = "Detects samples of CHAIRSMACK based on unique PE metadata (i.e. imphash and rich PE header hash)"
        reference = "https://mandiant.com/resources/blog/apt42-charms-cons-compromises"
        hash = "a37a290863fe29b9812e819e4c5b047c44e7a7d7c40e33da6f5662e1957862ab"

    condition:
        pe.imphash() == "72f60d7f4ce22db4506547ad555ea0b1" or 
        hash.md5(pe.rich_signature.clear_data) == "c0de41e45352714500771d43f0d8c4c3"
}
```

[I've written a script](https://github.com/BitsOfBinary/yarabuilder-examples/blob/main/pe/yarabuilder_pe.py) that can generate rules from these values (making use of [pefile](https://github.com/erocarrera/pefile) which makes this parsing very straightforward!), and you can also get these values from other platforms that parse files, such as VirusTotal, AlienVault, MalwareBazaar, and so on!

So next time you are about to write some rules for a PE binary, use the imphash and rich header hash for some quick and easy rules! These shouldn't be intended to replace more rigorous rules (i.e. based on strings, code segments, anomalies, etc.), but can build in some redundancy into your detection capabilities. 

## Disclaimer
As always with YARA rules, test to make sure your rules behave as expected! Blindly using an imphash or rich header hash might get you lots of false positives. E.g., the [imphash for a .NET PE binary](https://twitter.com/cyb3rops/status/1511725863414419459) (`f34d5f2d4577ed6d9ceec516c1f5a744`) will be the same across many different files, due to them all importing the same library (`mscoree.dll`) and the same function from that library (`_CorExeMain`).

# Day 4 - YARA Module Example 2 - PDB Paths
PDB files are generated by Visual Studio for the purposes of debugging. As such, binaries generated using the `Debug` option in Visual Studio will have a hardcoded path to where the PDB file lies. This path can reveal some useful information, such as the drive/username of the user that compiled the file, or internal names given to the project.

All kinds of heuristics can be used on PDB paths (see Steve Miller's [Swear Engine](https://twitter.com/stvemillertime/status/1100399116876533760)), so it's worth trying to see what weird things you can find!

```
import "pe"

rule Heuristic_PE_PDB_Self_Identifying_as_Malware {
    meta:
        description = "Detects files that identify themselves as malware"
        
    condition:
        pe.pdb_path icontains "malware"
}
```

Note: `icontains` is an operator that acts as a case-insensitive `contains`. If you've not seen this operator, I highly recommend checking out all the [operators listed in the YARA documentation](https://yara.readthedocs.io/en/stable/writingrules.html#conditions); there are some really useful ones!

For a more practical example, we could consider the SessionManager IIS backdoor as [reported on by Kaspersky](https://securelist.com/the-sessionmanager-iis-backdoor/106868/). In the IoCs section of this report, they list the following PDB paths:
- `C:\Users\GodLike\Desktop\t\t4\StripHeaders-master\x64\Release\sessionmanagermodule.pdb`
- `C:\Users\GodLike\Desktop\t\t4\SessionManagerModule\x64\Release\sessionmanagermodule.pdb`
- `C:\Users\GodLike\Desktop\t\t4\SessionManagerV2Module\x64\Release\sessionmanagermodule.pdb`
- `C:\Users\GodLike\Desktop\t\t4\SessionManagerV3Module\x64\Release\sessionmanagermodule.pdb`
- `C:\Users\GodLike\Desktop\t\t0\Hook-PasswordChangeNotify-master\HookPasswordChange\x64\Release\HookPasswordChange.pdb`

As you can see, there are some strings across these PDBs, such as `\GodLike\`, `\t\t[0-9]\`, and `sessionmanagermodule.pdb`. It can sometimes take some trial and error to figure out which segments of a PDB path will be good to signature, but a first pass at writing a rule making use of the PE Module could be as follows:
```
import "pe"

rule SessionManager_IIS_Backdoor_PDB_Path_Segments {
    meta:
        description = "Detects the SessionManager IIS backdoor based on some unique PDB path segments"
        reference = "https://securelist.com/the-sessionmanager-iis-backdoor/106868/"
        
    condition:
        pe.pdb_path contains "\\GodLike\\" or
        pe.pdb_path matches /\\t\\t[0-9]\\/ or
        pe.pdb_path endswith "\\sessionmanagermodule.pdb"
}
```
Of course you could write a rule that looks for these strings in general within a sample without using the PE module, but the regex `\t\t[0-9]\` might not perform as efficiently on larger samples as opposed to just evaluating on the much smaller PDB path variable.

# Day 5 - Introducing the YARA LNK module
The [Windows Shell Link file format](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/16cb4ca1-9339-4d0c-a68d-bf1d6cc0f943) (or LNK) has been used by threat actors for years for malicious purposes (reference: [https://attack.mitre.org/techniques/T1204/001/](https://attack.mitre.org/techniques/T1204/001/))! Whether to download a next-stage payload, or set persistence on an infected system, the LNK file format can be quite versatile. It has also seen an uptick in use as part of initial infection chains due to Microsoft [disabling macros by default from documents downloaded from the internet](https://learn.microsoft.com/en-us/deployoffice/security/internet-macros-blocked).

With all this combined, I wanted to [put together a YARA module for LNK files](https://github.com/VirusTotal/yara/pull/1732) to aid defenders in being able to triage, parse, and detect them.

The next few weeks of posts will go into detail of how to use the module, and some rules that are possible to write using it. Along the way, we'll hopefully learn some cool features of the LNK file format that will be useful to consider in general (check out [Greg Lesnewich's](https://twitter.com/greglesnewich) **#100DaysofYARA** contributions so far [to see some cool LNK rules](https://github.com/g-les/100DaysofYARA/blob/main/100DaysofYARA_2023_Week1_LNKPark.ipynb)).

## Shoutouts
I wouldn't have been able to write this module without being able to see the source code of other YARA modules, and through the variety of currently available LNK parsers to help validate my output (such as [exiftool](https://exiftool.org/TagNames/LNK.html) or [Silas Cutler's](https://twitter.com/silascutler) [LnkParse](https://github.com/silascutler/LnkParse) Python module).

Also shoutouts to [Ollie Whitehouse](https://twitter.com/ollieatnowhere) who gave me some great tips [to avoid bugs in my C code](https://twitter.com/ollieatnowhere/status/1556554996866596865) (which was very much needed!), and [Wesley Shields](https://twitter.com/wxs) for an early tip to make sure [I didn't do silly things dereferencing pointers in C](https://twitter.com/wxs/status/1483544341272576009).

And of course, shoutout to [Victor Alvarez](https://twitter.com/plusvic) and all the YARA maintainers for creating and developing this awesome tool!

## Acknowledgments
While I think the LNK module will give a great deal of flexibility to writing YARA rules for LNK files, a great deal of work has already done by others to write rules for LNKs! Please go check out rules from the following authors:
- Bart (@bartblaze): [https://github.com/bartblaze/Yara-rules/blob/master/rules/generic/LNK_Ruleset.yar](https://github.com/bartblaze/Yara-rules/blob/master/rules/generic/LNK_Ruleset.yar)
- Florian Roth (@cyb3rops): [https://github.com/Neo23x0/signature-base/blob/05ef26965be930fade49e5dcba73b9fefc04757e/yara/gen_susp_lnk_files.yar](https://github.com/Neo23x0/signature-base/blob/05ef26965be930fade49e5dcba73b9fefc04757e/yara/gen_susp_lnk_files.yar)

If you know of any other open source LNK YARA rulesets, please give me a shout and I can update this page with them! Check out the repo set up for **#100DaysofYARA** to see some further LNK rules available as well: [https://github.com/100DaysofYARA/2023](https://github.com/100DaysofYARA/2023)

# Day 6 - Installing YARA with the LNK module
The LNK is currently not included by default with YARA; at the time of writing, it is still awaiting approval to be merged in via a pull request on GitHub.

As such, if you want to test out the LNK module, you'll need to:
- Clone the LNK module branch from here: [https://github.com/BitsOfBinary/yara/tree/lnk-module](https://github.com/BitsOfBinary/yara/tree/lnk-module)
- Follow the instructions in the docs to install YARA: [https://yara.readthedocs.io/en/stable/gettingstarted.html](https://yara.readthedocs.io/en/stable/gettingstarted.html)

The rough set of commands you'll need to run if installing on Linux are as follows:
```
sudo apt-get install automake libtool make gcc pkg-config flex bison
./bootstrap.sh
./configure
make
sudo make install
```

You can optionally run `make check` to see if all the tests pass for YARA as well, although if you're able to run `yara --help` at this stage as see output then you'll know it has compiled and installed correctly!

The LNK module is available for any operating system, so you can compile it as normal for Linux/macOS, or use the Visual Studio projects to build it for Windows. [@r0ny_123](https://twitter.com/r0ny_123) also pointed out to me that you can grab Windows binaries from the AppVeyor builds (i.e. part of the regular CI/CD applied to YARA), e.g.: [https://ci.appveyor.com/project/plusvic/yara/build/job/wthlb30bklmlns0a/artifacts](https://ci.appveyor.com/project/plusvic/yara/build/job/wthlb30bklmlns0a/artifacts)

You can test if it the LNK module itself is working properly by trying to run the following rule and making sure there are no errors:
```
import "lnk"

rule test {
    condition:
        filesize > 0
}
```

The branch that the LNK module is on will install it by default, so you don't need to add any flags to `configure` when compiling YARA.

I'm aiming to keep the LNK module branch up to date with the [main branch of YARA](https://github.com/VirusTotal/yara), so all other features of YARA will be available if you compile the LNK module branch!

## Troubleshooting
Let me know if you have any issues installing the module. Personally I've found that when compiling via WSL on Windows that the `./bootstrap.sh` command doesn't work as expected, but if I manually run the command inside the script file, that is `autoreconf --force --install`, then it works as expected!

## Any feedback on the module?
If you have any feedback on the module (whether suggestions for how it could be used, support for it being merged in, etc.) please feel free to drop a comment on the open pull request on GitHub!

I hope that the module will be merged in by default into YARA one day (or at least, optionally available when compiling YARA from source).

# Day 7 - Parsing an LNK file with the LNK module
The nice thing about the YARA file parsing modules is that you can output the populated variables by adding the `-D` flag on the command line. If you would like to test this out, and don't have LNKs to hand, then sample LNK files can be found in the `tests\data` directory of the LNK module branch (all prefixed with `lnk-`). So if you save the following rule to `test_lnk.yar`:
```
import "lnk"

rule test {
    condition:
        filesize > 0
}
```
And run the command `yara -D test_lnk.yar tests/data/lnk-standard` (where `lnk-standard` is provided in the [LNK documentation](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-shllink/16cb4ca1-9339-4d0c-a68d-bf1d6cc0f943)), you should see the following output:
```
lnk
        is_malformed = 0
        overlay_offset = YR_UNDEFINED
        has_overlay = 0
        vista_and_above_id_list_data
                item_id_list
                number_of_item_ids = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_vista_and_above_id_list_data = 0
        tracker_data
                droid_birth_file_identifier = "\xecF\xcd{"\x7f\xdd\x11\x94\x99\x00\x13r\x16\x87J"
                droid_birth_volume_identifier = "@x\xc7\x94G\xfa\xc7F\xb3V\-\xc6\xb6\xd1\x15"
                droid_file_identifier = "\xecF\xcd{"\x7f\xdd\x11\x94\x99\x00\x13r\x16\x87J"
                droid_volume_identifier = "@x\xc7\x94G\xfa\xc7F\xb3V\-\xc6\xb6\xd1\x15"
                machine_id = "chris-xps"
                block_signature = 2684354563
                block_size = 96
        has_tracker_data = 1
        special_folder_data
                offset = YR_UNDEFINED
                special_folder_id = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_special_folder_data = 0
        shim_data
                layer_name = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_shim_data = 0
        property_store_data
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_property_store_data = 0
        known_folder_data
                known_folder_id
                offset = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_known_folder_data = 0
        icon_environment_data
                target_unicode = YR_UNDEFINED
                target_ansi = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_icon_environment_data = 0
        environment_variable_data
                target_unicode = YR_UNDEFINED
                target_ansi = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_environment_variable_data = 0
        darwin_data
                darwin_data_unicode = YR_UNDEFINED
                darwin_data_ansi = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_darwin_data = 0
        console_fe_data
                code_page = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_console_fe_data = 0
        console_data
                color_table
                history_no_dup = YR_UNDEFINED
                number_of_history_buffers = YR_UNDEFINED
                history_buffer_size = YR_UNDEFINED
                auto_position = YR_UNDEFINED
                insert_mode = YR_UNDEFINED
                quick_edit = YR_UNDEFINED
                full_screen = YR_UNDEFINED
                cursor_size = YR_UNDEFINED
                face_name = YR_UNDEFINED
                font_weight = YR_UNDEFINED
                font_family = YR_UNDEFINED
                font_size = YR_UNDEFINED
                window_origin_y = YR_UNDEFINED
                window_origin_x = YR_UNDEFINED
                window_size_y = YR_UNDEFINED
                window_size_x = YR_UNDEFINED
                screen_buffer_size_y = YR_UNDEFINED
                screen_buffer_size_x = YR_UNDEFINED
                popup_fill_attributes = YR_UNDEFINED
                fill_attributes = YR_UNDEFINED
                block_signature = YR_UNDEFINED
                block_size = YR_UNDEFINED
        has_console_data = 0
        icon_location = YR_UNDEFINED
        command_line_arguments = YR_UNDEFINED
        working_dir = "C\x00:\x00\\x00t\x00e\x00s\x00t\x00"
        relative_path = ".\x00\\x00a\x00.\x00t\x00x\x00t\x00"
        name_string = YR_UNDEFINED
        link_info
                common_path_suffix_unicode = YR_UNDEFINED
                local_base_path_unicode = YR_UNDEFINED
                common_path_suffix = "\x00"
                common_network_relative_link
                        device_name_unicode = YR_UNDEFINED
                        net_name_unicode = YR_UNDEFINED
                        device_name = YR_UNDEFINED
                        net_name = YR_UNDEFINED
                        device_name_offset_unicode = YR_UNDEFINED
                        net_name_offset_unicode = YR_UNDEFINED
                        network_provider_type = YR_UNDEFINED
                        device_name_offset = YR_UNDEFINED
                        net_name_offset = YR_UNDEFINED
                        flags = YR_UNDEFINED
                        size = YR_UNDEFINED
                has_common_network_relative_link = YR_UNDEFINED
                local_base_path = "C:\test\a.txt"
                volume_id
                        data = "\x00"
                        volume_label_offset_unicode = YR_UNDEFINED
                        volume_label_offset = 16
                        drive_serial_number = 813337217
                        drive_type = 3
                        size = 17
                has_volume_id = 1
                common_path_suffix_offset_unicode = YR_UNDEFINED
                local_base_path_offset_unicode = YR_UNDEFINED
                common_path_suffix_offset = 59
                common_network_relative_link_offset = 0
                local_base_path_offset = 45
                volume_id_offset = 28
                flags = 1
                header_size = 28
                size = 60
        link_target_id_list
                item_id_list_size = 189
                number_of_item_ids = 4
                item_id_list
                        [0]
                                size = 18
                                data = "\x1fP\xe0O\xd0 \xea:i\x10\xa2\xd8\x08\x00+00\x9d"
                        [1]
                                size = 23
                                data = "/C:\\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                        [2]
                                size = 68
                                data = "1\x00\x00\x00\x00\x00,9i\xa3\x10\x00test\x00\x002\x00\x07\x00\x04\x00\xef\xbe,9e\xa3,9i\xa3&\x00\x00\x00\x03\x1e\x00\x00\x00\x00\xf5\x1e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00t\x00e\x00s\x00t\x00\x00\x00\x14\x00"
                        [3]
                                size = 70
                                data = "2\x00\x00\x00\x00\x00,9i\xa3 \x00a.txt\x004\x00\x07\x00\x04\x00\xef\xbe,9i\xa3,9i\xa3&\x00\x00\x00-n\x00\x00\x00\x00\x96\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00a\x00.\x00t\x00x\x00t\x00\x00\x00\x14\x00"
        has_hotkey = 0
        hotkey_modifier_flags = 0
        hotkey = YR_UNDEFINED
        hotkey_flags = 0
        show_command = 1
        icon_index = 0
        file_attributes_flags = 32
        link_flags = 524443
        file_size = 0
        write_time = 1221251237
        access_time = 1221251237
        creation_time = 1221251237
        is_lnk = 1
        TMPF_DEVICE = 8
        TMPF_TRUETYPE = 4
        TMPF_VECTOR = 2
        TMPF_FIXED_PITCH = 1
        TMPF_NONE = 0
        FF_DECORATIVE = 80
        FF_SCRIPT = 64
        FF_MODERN = 48
        FF_SWISS = 32
        FF_ROMAN = 16
        FF_DONTCARE = 0
        BACKGROUND_INTENSITY = 128
        BACKGROUND_RED = 64
        BACKGROUND_GREEN = 32
        BACKGROUND_BLUE = 16
        FOREGROUND_INTENSITY = 8
        FOREGROUND_RED = 4
        FOREGROUND_GREEN = 2
        FOREGROUND_BLUE = 1
        WNNC_NET_GOOGLE = 4390912
        WNNC_NET_MS_NFS = 4325376
        WNNC_NET_MFILES = 4259840
        WNNC_NET_RSFX = 4194304
        WNNC_NET_VMWARE = 4128768
        WNNC_NET_DRIVEONWEB = 4063232
        WNNC_NET_ZENWORKS = 3997696
        WNNC_NET_KWNP = 3932160
        WNNC_NET_DFS = 3866624
        WNNC_NET_AVID1 = 3801088
        WNNC_NET_OPENAFS = 3735552
        WNNC_NET_QUINCY = 3670016
        WNNC_NET_SRT = 3604480
        WNNC_NET_TERMSRV = 3538944
        WNNC_NET_LOCK = 3473408
        WNNC_NET_IBMAL = 3407872
        WNNC_NET_SHIVA = 3342336
        WNNC_NET_HOB_NFS = 3276800
        WNNC_NET_MASFAX = 3211264
        WNNC_NET_OBJECT_DIRE = 3145728
        WNNC_NET_KNOWARE = 3080192
        WNNC_NET_DAV = 3014656
        WNNC_NET_EXIFS = 2949120
        WNNC_NET_YAHOO = 2883584
        WNNC_NET_FOXBAT = 2818048
        WNNC_NET_STAC = 2752512
        WNNC_NET_EXTENDNET = 2686976
        WNNC_NET_3IN1 = 2555904
        WNNC_NET_CSC = 2490368
        WNNC_NET_RDR2SAMPLE = 2424832
        WNNC_NET_TWINS = 2359296
        WNNC_NET_DISTINCT = 2293760
        WNNC_NET_FJ_REDIR = 2228224
        WNNC_NET_PROTSTOR = 2162688
        WNNC_NET_DECORB = 2097152
        WNNC_NET_RIVERFRONT2 = 2031616
        WNNC_NET_RIVERFRONT1 = 1966080
        WNNC_NET_SERNET = 1900544
        WNNC_NET_MANGOSOFT = 1835008
        WNNC_NET_DOCUSPACE = 1769472
        WNNC_NET_AVID = 1703936
        VALID_NET_TYPE = 2
        VALID_DEVICE = 1
        DRIVE_RAMDISK = 6
        DRIVE_CDROM = 5
        DRIVE_REMOTE = 4
        DRIVE_FIXED = 3
        DRIVE_REMOVABLE = 2
        DRIVE_NO_ROOT_DIR = 1
        DRIVE_UNKNOWN = 0
        COMMON_NETWORK_RELATIVE_LINK_AND_PATH_SUFFIX = 2
        VOLUME_ID_AND_LOCAL_BASE_PATH = 1
        HOTKEYF_ALT = 4
        HOTKEYF_CONTROL = 2
        HOTKEYF_SHIFT = 1
        SW_SHOWMINNOACTIVE = 7
        SW_SHOWMAXIMIZED = 3
        SW_SHOWNORMAL = 1
        FILE_ATTRIBUTE_ENCRYPTED = 16384
        FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192
        FILE_ATTRIBUTE_OFFLINE = 4096
        FILE_ATTRIBUTE_COMPRESSED = 2048
        FILE_ATTRIBUTE_REPARSE_POINT = 1024
        FILE_ATTRIBUTE_SPARSE_FILE = 512
        FILE_ATTRIBUTE_TEMPORARY = 256
        FILE_ATTRIBUTE_NORMAL = 128
        RESERVED_2 = 64
        FILE_ATTRIBUTE_ARCHIVE = 32
        FILE_ATTRIBUTE_DIRECTORY = 16
        RESERVED_1 = 8
        FILE_ATTRIBUTE_SYSTEM = 4
        FILE_ATTRIBUTE_HIDDEN = 2
        FILE_ATTRIBUTE_READONLY = 1
        KEEP_LOCAL_ID_LIST_FOR_UNC_TARGET = 67108864
        PREFER_ENVIRONMENT_PATH = 33554432
        UNALIAS_ON_SAVE = 16777216
        ALLOW_LINK_TO_LINK = 8388608
        DISABLE_KNOWN_FOLDER_ALIAS = 4194304
        DISABLE_KNOWN_FOLDER_TRACKING = 2097152
        DISABLE_LINK_PATH_TRACKING = 1048576
        ENABLE_TARGET_METADATA = 524288
        FORCE_NO_LINK_TRACK = 262144
        RUN_WITH_SHIM_LAYER = 131072
        UNUSED_2 = 65536
        NO_PIDL_ALIAS = 32768
        HAS_EXP_ICON = 16384
        RUN_AS_USER = 8192
        HAS_DARWIN_ID = 4096
        UNUSED_1 = 2048
        RUN_IN_SEPARATE_PROCESS = 1024
        HAS_EXP_STRING = 512
        FORCE_NO_LINK_INFO = 256
        IS_UNICODE = 128
        HAS_ICON_LOCATION = 64
        HAS_ARGUMENTS = 32
        HAS_WORKING_DIR = 16
        HAS_RELATIVE_PATH = 8
        HAS_NAME = 4
        HAS_LINK_INFO = 2
        HAS_LINK_TARGET_ID_LIST = 1
test tests/data/lnk-standard
```
The variables printed are the ones that are set by the LNK module, in reverse order of when they have been parsed. They are a combination of fixed values (i.e. the symbolic constants defined in the LNK docs), parsed values from the LNK (either as single variables, or arrays/dictionaries), and some boolean values set about general information of the LNK.

The layer of indentation corresponds to how you can access the variable. If you want to access the `file_size` variable, you would do so via `lnk.file_size`. If you want to access `number_of_item_ids`, you can via `lnk.link_target_id_list.number_of_item_ids`.

As you can see, not all variables are set. The LNK file specification points out that many sections of the file format are optional, so don't expect the majority of variables to be set on each LNK file you parse!

If you want detail on each of the variables parsed out/available, they are documented in `docs\modules\lnk.rst` (which you'll have to build yourself or just read the `.rst` file in a text editor). I've also manually converted these docs to markdown for these blog posts (although they won't remain up to date with any changes) which you can find here: [https://bitsofbinary.github.io/yara/2023/01/05/lnk_module_documentation.html](https://bitsofbinary.github.io/yara/2023/01/05/lnk_module_documentation.html)

# Day 8 - Testing if a file is an LNK
Let's start with a straightforward rule: determining whether a file is an LNK in the first place. This is possible due to the LNK file header size and CLSID being fixed values:
![From the LNK docs](/assets/2023-01-08_shell_lnk_header_and_clsid.png)

If you are doing this with "pure" YARA, the rule would look like this:
```
rule is_lnk {
    condition:
        uint32(0) == 0x0000004C and
        uint32(4) == 0x00021401 and
        uint32(8) == 0x00000000 and
        uint32(12) == 0x000000C0 and
        uint32(16) == 0x46000000
}
```

If you're unfamiliar with the syntax used, YARA has a variety of operators to compare byte values at specific offsets in a file. These come in the form of the `int` and `uint` operators (which are both signed and unsigned respectively), and are available for 8-bit, 16-bit and 32-bit values. Later versions of YARA have also added big endian versions of these operators, so the first line of the condition of this rule could also be written as `uint32be(0) == 0x4C000000`.

As such, it is possible to determine whether a file is an LNK using this method, but requires you to go and read the LNK docs/keep a copy of this condition somewhere for use each time (plus it's a little verbose if you're replicating it across many rules).

With the LNK module, this same rule reduces to:
```
import "lnk"

rule is_lnk {
    condition:
        lnk.is_lnk
}
```

The `lnk.is_lnk` variable is a boolean value, set to `1` if the file being scanned is an LNK, and `0` if it isn't. As such, just validating that this value is true is enough to determine whether you're scanning an LNK or not!

(**Note**: you don't need to do `lnk.is_lnk == true`, as it is implicitly checking if it is true)

## Aside - Thoughts on file header validation
If you've been following #100DaysofYARA so far and seen [@greglesnewich's](https://twitter.com/greglesnewich) LNK rules, you'll notice that he does the check `uint32be(0x0) == 0x4C000000` to see if a file is an LNK.

I can't think of any cases where this won't be sufficient! Files starting with those 4 bytes are almost certainly going to be LNKs. It's similar to how a lot of us will write `uint16(0) == 0x5A4D` to check that a file is a PE; we're not actually checking the PE header or even validating the rest of the header itself, but just seeing the `MZ` string at the start is enough for us.

Checking both the header size and CLSID is a bit overkill for a rule's condition I will admit. However, if you want the assurance of the full header being present, then I think `lnk.is_lnk` is a lot more concise than the five `uint32` checks required.

# Day 9 - Checking LNK Timestamps
LNKs have three timestamps in their headers: creation time, access time, and write time. All of these are timestamps are in the [FILETIME](https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime) structure format, but for ease of use the LNK module converts them to Unix timestamps (e.g. to make them compatible with the [time module](https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime)).

![LNK timestamps](/assets/2023-01-09_lnk_timestamps.png)

As such, you can write rules based on these timestamps for a variety of purposes, such as:
- Clustering LNK files with the same timestamps
- Looking for anomalies in LNK timestamps

For example, the following rule will look for an LNK file that has supposedly been created after it has been accessed/last been written to:
```
import "lnk"

rule Heuristic_LNK_Created_After_Access_or_Write {
    meta:
        description = "Detects an LNK file with a creation timestamp later than that of its access/write timestamp"
        
    condition:
        lnk.creation_time > lnk.access_time or
        lnk.creation_time > lnk.write_time
}
```

And here's another one that finds LNK files that have been created in the future:
```
import "lnk"
import "time"

rule Heuristic_LNK_Created_in_Future {
    meta:
        description = "Detects LNK files with a creation timestamp in the future"
        
    condition:
        lnk.creation_time > time.now()
}
```

Or maybe, you want to look for LNKs where the timestamp has been removed:
```
import "lnk"

rule Heuristic_LNK_Empty_Timestamp {
    meta:
        description = "Detects an LNK file with a creation/write/access timestamp that has been zero'ed out"
        
    condition:
        lnk.creation_time == 0 or
        lnk.write_time == 0 or
        lnk.access_time == 0
}
```

This last rule can be written in pure YARA as follows:
```
rule Heuristic_LNK_Zeroed_Header_Timestamp {
    meta:
        description = "Detects an LNK file with a creation/write/access timestamp that has been zeroed out"
        
    condition:
        uint32(0) == 0x0000004C and
        uint32(4) == 0x00021401 and
        uint32(8) == 0x00000000 and
        uint32(12) == 0x000000C0 and
        uint32(16) == 0x46000000 and
        (
            // Creation timestamp
            (
                uint32(28) == 0 and uint32(32) == 0
            ) or
            // Access timestamp
            (
                uint32(36) == 0 and uint32(40) == 0
            ) or
            // Write timestamp
            (
                uint32(44) == 0 and uint32(48) == 0
            )
        )
}
```
This is possible to do due to the fixed offsets in the LNK header, but makes for a more verbose rule!

(EDIT: it actually looks fairly common that LNKs will have no timestamps; go figure!)

## Think about timestamps in different ways
Timestamp anomalies can lead to some really interesting rules! For example, check out [Costin Raiu's](https://twitter.com/craiu) slides from a [presentation on writing good YARA rules](https://www.slideshare.net/KasperskyLabGlobal/upping-the-apt-hunting-game-learn-the-best-yara-practices-from-kaspersky), where slides 48-50 describe how it is possible to track TripleFantasy based on an impossible timestamp in a PE.

Maybe there are more possibilities to create YARA rules for LNKs based on strange timestamp features? Have a go if you've got an idea!

# Day 10 - LNK File Attributes
The LNK file headers (and some variables throughout the file format) have flags set with each bit corresponding to different attributes. While a lot of these are more for contextual purposes, some can tell us information about the LNK file or its target, which can be used for heuristics/anomaly detection.

For example, one of the flags present is `FileAttributesFlags`, which specify the attributes of the link target. An example rule could be to look for LNKs with the `FILE_ATTRIBUTE_HIDDEN` bit (i.e. `0x00000002`) set:
```
import "lnk"

rule Heuristic_LNK_Hidden_Link_Target {
    meta:
        description = "Detects LNK files with link targets that are hidden"
        
    condition:
        lnk.file_attributes_flags & lnk.FILE_ATTRIBUTE_HIDDEN
}
```

![LNK file attribute flags](/assets/2023-01-10_lnk_file_attributes_flags.png)

You can find what all these values correspond to in `yara/libyara/include/yara/lnk.h`. For example, this rule would be the following in pure YARA:
```
rule Heuristic_LNK_Hidden_Link_Target {
    meta:
        description = "Detects LNK files with link targets that are hidden"
        
    condition:
        uint32(0) == 0x0000004C and
        uint32(4) == 0x00021401 and
        uint32(8) == 0x00000000 and
        uint32(12) == 0x000000C0 and
        uint32(16) == 0x46000000 and
        uint32(24) & 0x00000002
}
```

(**Note:** this bit being set appears to be very common, so on it's own may not be enough for a good hunting rule, but combined with other values could lead to some interesting ones)