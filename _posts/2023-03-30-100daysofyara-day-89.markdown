---
layout: post
title: "100 Days of YARA - Day 89"
date: 2023-03-30 00:00:00 -0000
categories: yara
---

# AcidBox - SSP DLL Code - Signaturing Crypto Routine - Part 3
Let's take a look at the [YaraGhidraGUIScript.java](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/ghidra_scripts/YaraGhidraGUIScript.java) window again:
![](/assets/2023-03-29_ghidra_yara_output.png)

Each instruction, along with its operands can be toggled to be masked. So for instance, if I decided that I didn't think the register `R8D` would be consistent across variants, I could toggle that value by clicking on the relevant boxes containing that register.

There are also options in the top of the window, which allow you to:
- Mask all non-instructions (data)
- Mask all operands
- Mask all scalars
- Mask all addresses

It's worth playing around with these to see what the corresponding output would look like. For instance, I personally wouldn't want to mask all operands in this case, although in larger blocks of code that may be useful. But masking all addresses may be useful here, which will mask the operand `dword ptr [RSP + 0x4]`. Here is an example of some of the instructions I have masked:
![](/assets/2023-03-30_ghidra_yara_output_masked.png)

If I cut out the last 3 wildcards (as they are no longer really needed), I can get the following rule:
```
rule AcidBox_SSP_DLL_Loader_Crypto_Routine_C {
    meta:
        description = "Detects AcidBox SSP DLL loaders, based on a unique cryptography routine"
        author = "BitsOfBinary"
        reference = "https://unit42.paloaltonetworks.com/acidbox-rare-malware/"
        hash = "003669761229d3e1db0f5a5b333ef62b3dffcc8e27c821ce9018362e0a2df7e9"
        
    strings:
        // 180013a71 0f  b6  04  32   MOVZX      EAX ,byte ptr [param_2  + RSI *0x1 ]
        // 180013a75 33  c8           XOR        param_1 ,EAX
        // 180013a77 88  0c  3a       MOV        byte ptr [param_2  + RDI *0x1 ],param_1
        // 180013a7a 41  ff  c0       INC        param_3
        // 180013a7d 44  89  44       MOV        dword ptr [RSP  + local_14 ],param_3
        //           24  04
        $ = {0f b6 04 32 33 c8 88 0c 3a 4? ff c? 4? 89}
        
    condition:
        any of them
}
```

Overall, it is worth playing around with instruction masking to see how far you can go before you start getting false positives. The more you want to reverse engineer the sample, the more context you will get to help you decide what you can/can't mask (e.g. in this case, most of the code is dealing with function parameters, which have been saved into specific registers, so the masking might not actually make that much of a difference).